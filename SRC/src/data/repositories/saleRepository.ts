/**
 * Sale Repository
 * WO-002 T2.2: Implementing repository pattern for Sales
 * WO-FE-007: Implementing Mapper Layer for Schema v2 Compatibility
 * 
 * Uses SupabaseAdapter to provide data access for Sales
 * Favor RPC `procesar_venta` for atomic creation
 * 
 * @module data/repositories/saleRepository
 */

import { Sale, SaleItem } from '../../types';
import { Database } from '../../types/database.types';
import { Decimal } from 'decimal.js';
import { createSupabaseRepository, EntityRepository, RepositoryMappers } from './supabaseAdapter';
import { getSupabaseClient, isSupabaseConfigured } from '../supabaseClient';
import { logger } from '../../utils/logger';
import { addToSyncQueue } from '../syncQueue';

// Constants
const TABLE_NAME = 'sales';
const STORAGE_KEY = 'tienda-sales';

// Type definitions
type SaleDB = Database['public']['Tables']['sales']['Row'];
type SaleInsert = Database['public']['Tables']['sales']['Insert'];

/**
 * Mapper Implementation for Sale
 * Enforces:
 * 1. Decimal (Domain) <-> number (DB)
 * 2. snake_case (DB) <-> camelCase (Domain)
 */
export const saleMapper: RepositoryMappers<SaleDB, Sale> = {
    toDomain: (row: SaleDB): Sale => {
        return {
            id: row.id,
            ticketNumber: row.ticket_number,
            date: row.created_at.split('T')[0], // Extract YYYY-MM-DD
            timestamp: row.created_at,
            // Items are not in the sales table (relation).
            // For list views, we might effectively return empty items or fetch separate.
            // As this is a generic getAll wrapper, we return empty structure adhering to type.
            items: [],
            total: new Decimal(row.total),
            paymentMethod: row.payment_method as any,
            // payments: Not stored in sales row directly (related tables)
            roundingDifference: row.rounding_difference ? new Decimal(row.rounding_difference) : undefined,
            effectiveTotal: new Decimal(row.total).add(row.rounding_difference ? new Decimal(row.rounding_difference) : 0),
            amountReceived: row.amount_received ? new Decimal(row.amount_received) : undefined,
            change: row.change_given ? new Decimal(row.change_given) : undefined,
            clientId: row.client_id || undefined,
            employeeId: row.employee_id,
            'syncStatus': row.sync_status as any
        };
    },
    toPersistence: (entity: Sale): SaleDB => {
        return {
            id: entity.id,
            ticket_number: entity.ticketNumber || 0, // Generated by DB, but if persisting local...
            created_at: entity.timestamp || new Date().toISOString(),
            // Fields specific to SaleDB
            payment_method: entity.paymentMethod,
            total: entity.total.toNumber(),
            employee_id: entity.employeeId || '', // Essential
            client_id: entity.clientId || null,
            amount_received: entity.amountReceived ? entity.amountReceived.toNumber() : null,
            change_given: entity.change ? entity.change.toNumber() : null,
            rounding_difference: entity.roundingDifference ? entity.roundingDifference.toNumber() : null,
            is_voided: false,
            void_reason: null,
            voided_by: null,
            local_id: null,
            sync_status: entity.syncStatus || 'synced',
            store_id: '' // Will be filled by adapter or context
        };
    }
};

/**
 * Interface extending base repository with sale-specific methods
 */
interface SalePayload {
    items: {
        productId: string;
        productName: string;
        quantity: number;
        price: any; // Decimal or number
        subtotal: any; // Decimal or number
    }[];
    total: any; // Decimal or number
    paymentMethod: 'cash' | 'nequi' | 'fiado' | 'mixed';
    payments?: { method: 'cash' | 'nequi' | 'fiado', amount: number, reference?: string }[];
    amountReceived?: any; // Decimal or number
    clientId?: string;
    employeeId?: string;
}

export interface SaleRepository extends EntityRepository<Sale> {
    processSale(saleData: SalePayload, storeId: string): Promise<{ success: boolean; id?: string; error?: string }>;
    getByDateRange(startDate: string, endDate: string, storeId?: string): Promise<Sale[]>;
}

// Create base repository with Mappers
const baseRepository = createSupabaseRepository<Sale, SaleDB>(
    TABLE_NAME,
    STORAGE_KEY,
    saleMapper
);

/**
 * Extended Sale Repository implementation
 */
export const saleRepository: SaleRepository = {
    ...baseRepository,

    /**
     * Process a new sale (Atomic Transaction)
     * Uses RPC 'procesar_venta' if online, fallback to Sync Queue if offline
     */
    async processSale(saleData: SalePayload, storeId: string): Promise<{ success: boolean; id?: string; error?: string }> {
        const isOnline = navigator.onLine && isSupabaseConfigured();

        // 1. Try Online (RPC)
        if (isOnline) {
            const supabase = getSupabaseClient();
            if (supabase) {
                try {
                    // Refactoring: Ensure Strict Types for RPC
                    // Decimal -> number conversion is critical here
                    const p_items = saleData.items.map(item => ({
                        product_id: item.productId,
                        quantity: item.quantity,
                        unit_price: new Decimal(item.price).toNumber(),
                        subtotal: new Decimal(item.subtotal).toNumber()
                    }));

                    const p_amount_received = saleData.amountReceived ? new Decimal(saleData.amountReceived).toNumber() : null;

                    const { data, error } = await supabase.rpc('procesar_venta', {
                        p_store_id: storeId,
                        p_items: p_items,
                        p_payment_method: saleData.paymentMethod === 'mixed' ? 'efectivo' : saleData.paymentMethod,
                        p_amount_received: p_amount_received,
                        p_client_id: saleData.clientId || null,
                        p_employee_id: saleData.employeeId
                    });

                    if (error) {
                        logger.error('[SaleRepo] RPC error:', error);
                        // If network error, fall through to offline handling
                        if (error.message && (error.message.includes('FetchError') || error.message.includes('Network request failed'))) {
                            // Fallthrough
                        } else {
                            return { success: false, error: error.message };
                        }
                    } else {
                        if (data && data.success) {
                            return { success: true, id: data.id };
                        } else {
                            return { success: false, error: data?.error || 'Unknown RPC error' };
                        }
                    }

                } catch (e) {
                    logger.error('[SaleRepo] RPC exception:', e);
                    // Fallthrough to offline
                }
            }
        }

        // 2. Offline Mode (Sync Queue)
        // Add to IndexedDB queue for later processing
        try {
            // Generate ID client-side for UI consistency
            const newId = crypto.randomUUID();

            // Normalize Payload for Queue
            // Ensure numbers for storage to match RPC expectations later
            const enrichedPayload = {
                ...saleData,
                // Ensure primitives for storage
                total: new Decimal(saleData.total).toNumber(),
                amountReceived: saleData.amountReceived ? new Decimal(saleData.amountReceived).toNumber() : undefined,
                items: saleData.items.map(item => ({
                    ...item,
                    price: new Decimal(item.price).toNumber(),
                    subtotal: new Decimal(item.subtotal).toNumber()
                })),
                storeId,
                id: newId
            };

            const queued = await addToSyncQueue('CREATE_SALE', enrichedPayload);

            if (queued) {
                return { success: true, id: newId };
            } else {
                return { success: false, error: 'Queue full or storage error' };
            }

        } catch (e: any) {
            return { success: false, error: e.message || 'Offline save failed' };
        }
    },

    /**
     * Get sales by date range
     */
    async getByDateRange(startDate: string, endDate: string, storeId?: string): Promise<Sale[]> {
        // Uses getAll which now uses Mappers
        const all = await baseRepository.getAll(storeId);
        return all.filter(s => {
            // Basic date string comparison
            return s.date >= startDate && s.date <= endDate;
        });
    }
};

export default saleRepository;
